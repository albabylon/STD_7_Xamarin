Бизнес-логика у вас будет на языке С#, а пользовательский интерфейс будет в основном описан с помощью языка XAML (рассмотрим дальше). 
Далее, при сборке и запуске вашего приложения под каждую платформу, этот один раз универсально описанный вами интерфейс, 
заданный на языке XAML, будет преобразован в нативный интерфейс каждой конкретной платформы


В основе Xamarin лежит фреймворк Mono, представляющий open-source реализацию .NET Framework. 
Mono может выполняться на разных платформах: LINUX, MacOS, Android (в основе которой тоже лежит линуксовое ядро, см. картинку выше), 
или iOS (Unix-подобное ядро, см. картинку).



Когда мы выполняем билд проекта в нашей IDE, происходит парсинг XAML-файлов, создается обычный С#-класс, 
который помещается в файл, имеющий расширение .g.cs, то есть у нас будет файл LoginPage.g.cs , который мы можем обнаружить в папке билда


Генерить полностью или частично интерфейс из XML-кода мы можем и динамически (в процессе выполнения программы).

Пример, когда такое может быть нужно: загрузка XML-кода из веб-сервиса, либо же ситуации, 
когда в зависимости от хода выполнения программы нам необходимо демонстрировать разный интерфейс в разных частях приложения.

Например, мы можем сделать так, чтобы на экране логина наша кнопка при нажатии меняла свой вид, подгружая новые значения свойств из XAML.

-----Расширения XAML-----
Нужны они для того, чтобы «пробрасывать» нужные нам значения из бизнес-логики на С# в XAML-представления и корректно их там отображать.


x:Static - ссылка на статические свойства, поля, перечисления enum,
позволяет передавать в страницу значения переменных и констант из кода С#.
x:Type - атрибут типа объекта
x:Array - создание массива объектов одного какого-либо типа
x:Null - присваивание атрибуту значения null
x:Reference - ссылки на именованные элементы страницы
StaticResource - ссылки на объекты
DynamicResource - отслеживание изменений ресурса
Binding - для установки связи между свойствами двух объектов (привязку данных рассмотрим позже)



В приложениях (как и на сайтах) часто возникает необходимость выводить на экран списки определенных сущностей (предметов) в виде массивов. 
Для этого и служат рассматриваемые здесь расширения: x:Array (определяет массив данных) и x:Type (определяет их тип).
<ListView.ItemsSource>
   <x:Array Type="{x:Type x:String}">
       <x:String>Кухня</x:String>
       <x:String>Ванная</x:String>
       <x:String>Гостиная</x:String>
       <x:String>Детская</x:String>
       <x:String>Прихожая</x:String>
   </x:Array>
</ListView.ItemsSource>


---Свои расширения XAML---
см. класс ButtonViewExtension.cs


----Дерево элементов XAML----

1. Элемент ContentPage - корневой элемент всей страницы. Содержит свойство Content.
В свойство Content не помещают напрямую простые элементы, а используют контейнеры компоновки, 
внутри которых может находиться сколько угодно элементов.

2. Элемент StackLayout - служит контейнером для вложенных элементов
Элементы расположены в ряд и занимают всю ширину экрана (что как раз и определяется контейнером StackLayout)

Контейнеры компоновки разработчики мобильных приложений называют лейаутами (от англ. Layout — макет, расположение).
И все контейнеры компоновки в Xamarin.Forms наследуются от общего базового класса Layout<T>.

а. StackLayout — располагает вложенные элементы друг за другом. 
Причём не обязательно вертикально, как у нас. Горизонтальная ориентация тоже возможна

б. AbsoluteLayout — позволяет задать абсолютное расположение вложенных элементов.

в. RelativeLayout — противоположно AbsoluteLayout, позволяет расположить дочерние 
элементы относительно самого лейаута или других элементов того же уровня.

г. Grid — позволяет так или иначе упорядочить дочерние элементы по строкам и столбцам 
(которые могут иметь как абсолютные, так и относительно-пропорциональные размеры)

д. FlexLayout — относительно новый контейнер (появился в Xamarin 3.0). Основан на адаптивном CSS-контейнере Flexible Box Layout Module. 
Похож на StackLayout тем, что позволяет расположить дочерние элементы друг за другом горизонтально или вертикально. Но имеет и некоторые другие преимущества.
К примеру, с его помощью можно уместить довольно большое количество дочерних элементов в один ряд или столбец (их размер будет адаптивным).
Также FlexLayout имеет много настроек для того, чтобы задать нужную ориентацию, выравнивание или адаптацию под определённые размеры экрана.

Все контейнеры компоновки позволяют получать (или добавлять) дочерние элементы при помощи свойства Children


3. ScrollView - компонент ScrollView позволяет уместить большое количество элементов на одном экране с помощью применения прокрутки.


4. AbsoluteLayout
Метод AbsoluteLayout.Children.Add(...), если мы это делаем с помощью С#-кода, имеет для этого несколько модификаций:
Add(View view) — обычное добавление элемента в контейнер с позицией по умолчанию;
Add(View view, Point point) — добавляем элемент, помещая его в точку Point;
Add(View view, Rectangle rectangle) — добавляем элемент в определенную область экрана, ограниченную прямоугольником Rectangle.

Point - Структура Point используется для представления точки на плоскости, задается следующим образом:
int x = 5;
int y = 10;
var Point = new Point(x, y);

Rectangle - Ещё одна структура для представления прямоугольной фигуры.
int x = 5;
int y = 10;
int width = 100;
int height = 80;   
var myRectangle = new Rectangle(x, y, width, height);




Для определения, какие именно величины в конфигурации элемента считать абсолютными, а какие — относительными, 
мы можем использовать тип-перечисление AbsoluteLayoutFlags.

None - все значения являются абсолютными
All - все значения относительные
WidthProportional - ширина будет относительной, остальное — в абсолютных величинах
HeightProportional - высота относительная, остальное нет
XProportional - координата X относительная
YProportional - координата Y относительная
PositionProportional - обе координаты, задающие позицию (X и Y), считаются относительными
SizeProportional - оба размера (ширина и высота) являются относительными



5. RelativeLayout - контейнер позволяет задать позиционирование элементов относительно краев контейнера или других вложенных элементов.

XConstraint — расположение относительно оси X.
YConstraint — расположение относительно оси Y.
HeightConstraint — высота.
WidthConstraint — ширина.

Для того чтобы задать XConstraint и YConstraint потребуется воспользоваться расширением разметки ConstraintExpression.


6. Grid - представляет содержимое в виде упорядоченных рядов и колонок, то есть по сути в виде таблицы.

При инициализации RowDefinitions и ColumnDefinitions, задавая высоту и ширину с помощью объекта GridLength, 
мы передаем первый параметр value = 1 для того, чтобы указать, что доля данного столбца или строки от всего пространства 
будет составлять 1 (то есть он будет занимать пространство целиком).

Grid предоставляет возможность устанавливать отступы между элементами.
Для этого служат свойства ColumnSpacing и RowSpacing.
Для того чтобы объединить несколько ячеек или столбцов, мы можем пользоваться свойствами RowSpan и ColumnSpan соответственно.